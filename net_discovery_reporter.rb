#!/usr/bin/env ruby
#
# net_discovery_reporter.rb
# 
# Net Discovery Reporter will create a Word DOCX formatted table and populate it with parsed results from Nmap XML files. 
# The open ports are sorted by port number, TCP then UDP. 
#
# This tool is designed to combine semi-unique scan results into a single table. Any overlapping open ports passed in
# will result in duplicates in the final output. If you supply sT, sS, and sV, expect duplicates. For this reason, and
# for the sake of scanning efficiency, I suggest you gather a list of open ports, sT, sS, and/or sU, and then version
# scan (sV) these hosts with the ports you found. Pass this final version in for a clean and fully populated table. 
#
# @TheJoSko - 02/03/2016
#
# Installation:
#   gem install ruby-nmap
#   gem install caracal
#
# Usage:
#   ./net_discovery_reporter.rb -f nmap_oX_file.xml
#   ./net_discovery_reporter.rb -d /directory/of/nmap_xml/files/
#   /net_discovery_reporter.rb -d ./


require 'optparse' #options parser
require 'nmap/xml' #nmap parser
require 'caracal' #OOXML 
#require 'pry' #debugging


#Parse command line options
x=nil
options = {}
optparse = OptionParser.new do |opts| 
  #The banner to display at the top
  opts.banner = "\nParse Nmap XML files and output to a Word DOCX table\n\nUsage: net_discover_reporter.rb [options]"
  opts.on( '-f', '--file FILENAME', 'Nmap XML file (singular)' ) { |file| options[:file] = file }
  opts.on( '-d', '--dir PATH', 'Directory of Nmap XML files' ) { |dir| options[:dir] = dir }
  opts.on( '-h', '--help', 'Display this screen' ) { puts opts; exit }
  x=opts
end.parse!(ARGV)


#If no options are specified, output help screen and exit
unless options.any?
  puts x
  exit
end

#Output filename
docx_filename = 'Net_Discovery_Report.docx'

#Instantiate empty arrays
results = []
open_ports = []

#Parse Nmap XML files, adding open ports to an array
def parse_nmap(xml_file, open_ports)
  Nmap::XML.new(xml_file) do |xml|

    xml.each_host do |host|
      ip = host.ip
      host.each_port do |port|
        if port.state == :open
          proto = port.protocol.upcase
          number = port.number
          service = port.service || nil
          if service
            name = service.name
            product = service.product
            version = service.version
          end
          open_ports << ["#{ip}","#{host}","#{proto}","#{number}","#{name} #{product} #{version}"]
        end
      end
    end
  end
end

def build_tables(open_ports, results)
  ports = []
  count = open_ports.count
  open_ports.sort_by!{ |a,b,c,d,e| a }
  open_ports.each.with_index(1) do |open_port, i|
    ip = open_port[0]
    host = open_port[1]
    proto = open_port[2]
    number = open_port[3]
    service = open_port[4]

    #If first row
    if i == 1
      ports << ["#{proto}","#{number}","#{service}"]
      if ip != open_ports[i][0] 
        #IP column
        ip_col = Caracal::Core::Models::TableCellModel.new margins: { top: 0, bottom: 0, left: 0, right: 0 } do
          p ip
        end
        #Hostname column
        host_col = Caracal::Core::Models::TableCellModel.new margins: { top: 0, bottom: 0, left: 0, right: 0 } do
          p host
        end
        #Ports table
        ports.sort_by!{ |a,b,c| [a,b.to_i] }.reverse
        port_table = Caracal::Core::Models::TableCellModel.new margins: { top: 0, bottom: 0, left: 0, right: 0 } do
          table ports do
            cell_style cols[0],  width: 1200
            cell_style cols[1],  width: 780
            cell_style cols[2],  width: 3420
          end
        end
        #Write to array of caracal tables
        results << [ip_col,host_col,port_table]        
        #Zero ports prior to next host
        ports = []
      end
    elsif i < count
      #If IP is same as next
      if ip == open_ports[i][0] 
        #Save ports to array
        ports << ["#{proto}","#{number}","#{service}"]
      else #If the next row is not the same, write to the results array
        #Save ports to array
        ports << ["#{proto}","#{number}","#{service}"]    
        #IP column
        ip_col = Caracal::Core::Models::TableCellModel.new margins: { top: 0, bottom: 0, left: 0, right: 0 } do
          p ip
        end
        #Hostname column
        host_col = Caracal::Core::Models::TableCellModel.new margins: { top: 0, bottom: 0, left: 0, right: 0 } do
          p host
        end
        #Ports table
        ports.sort_by!{ |a,b,c| [a,b.to_i] }.reverse
        port_table = Caracal::Core::Models::TableCellModel.new margins: { top: 0, bottom: 0, left: 0, right: 0 } do
          table ports do
            cell_style cols[0],  width: 1200
            cell_style cols[1],  width: 780
            cell_style cols[2],  width: 3420
          end
        end
        #Write to array of caracal tables
        results << [ip_col,host_col,port_table]          
        #Zero ports prior to next host
        ports = []
      end
    else #Last row
      ports << ["#{proto}","#{number}","#{service}"]
      #IP column
      ip_col = Caracal::Core::Models::TableCellModel.new margins: { top: 0, bottom: 0, left: 0, right: 0 } do
        p ip
      end
      #Hostname column
      host_col = Caracal::Core::Models::TableCellModel.new margins: { top: 0, bottom: 0, left: 0, right: 0 } do
        p host
      end
      #Ports table
      ports.sort_by!{ |a,b,c| [a,b.to_i] }.reverse
      port_table = Caracal::Core::Models::TableCellModel.new margins: { top: 0, bottom: 0, left: 0, right: 0 } do
        table ports do
          cell_style cols[0],  width: 1200
          cell_style cols[1],  width: 780
          cell_style cols[2],  width: 3420
        end
      end
      #Write to array of caracal tables
      results << [ip_col,host_col,port_table]        
    end
  end
end


#Create a DOCX file and instantiate it for editing
Caracal::Document.save docx_filename do |docx|
  docx.style do   #Default document style
    id 'Normal'
    name 'Normal'
    font 'Trebuchet MS'
    size '18'   #Measured in half-points (18 = 9pt font)
    line '240'   #Measured in twips
  end

  #Parse each Nmap XML file
  if options[:dir]
    Dir.glob(options[:dir] + '*.xml').each do |xml_file|
      parse_nmap(xml_file, open_ports)
      puts "Parsing: " + xml_file
    end
  else
    parse_nmap(options[:file], open_ports)
    puts "Parsing: " + options[:file]
  end

  #Create the document header timestamp and options
  docx.p do
    text 'Forward delete the space between the two tables and Word will merge them together.', color: 'FF0000', underline: 'true'
    br
    br
    text 'It is a dumb workaround, but combining tables/merging cells is a major PITA in code.'
    br
    br
    text 'Generated: ' + DateTime.now.to_s
    br
    br
    text 'options: ' + options.to_s
    br
  end

  #Build the results table
  puts "Building table ..."
  build_tables(open_ports, results)

  #Create the DOCX table from the results array
  header = ['IP Address', 'Hostname (if resolved)', 'Protocol', 'Port', 'Service']
  docx.table [header], border_size: 2 do
    border_color '0085C3'
    cell_style rows[0],  background: '0085C3', color: 'ffffff', bold: true   #Header row blue background, white text
    cell_style cols[0],  width: 1700
    cell_style cols[1],  width: 2360
    cell_style cols[2],  width: 1200
    cell_style cols[3],  width: 780
    cell_style cols[4],  width: 3320
  end

  docx.table results, border_size: 2 do
    border_color '0085C3'
    cell_style cols[0], bold: true, width: 1700
    cell_style cols[1], width: 2360
    cell_style cols[2], width: 5300
    cell_style cells,   margins: { top: 100, bottom: 0, left: 100, right: 100 }
  end
  puts "Writing to #{docx_filename}"
end

puts "Done"
