#!/usr/bin/env ruby
#
# net_discovery_reporter.rb
# 
# Net Discovery Reporter will create a Word DOCX formatted table and populate it with parsed results from Nmap XML files. 
# The open ports are sorted by port number, TCP then UDP. 
#
# If duplicate port listings are found when parsing the input files, the longer service (typically found with sV) will be 
# retained. Any subsequent services for that IP/PORT/PROTO that have the same or shorter service description length will 
# be dropped. This allows you to run the tool with nmap XML output from sT, sS, sU, sV, etc. scans, and it will populate a 
# table of unique open ports with the longest service description retained. 
#
# @TheJoSko - 02/03/2016
#
# Installation:
#   gem install ruby-nmap
#   gem install caracal
#
# Usage:
#   Single File:
#     ./net_discovery_reporter.rb -f nmap_oX_file.xml
#   Directory:
#     ./net_discovery_reporter.rb -d /directory/of/nmap_xml/files/
#     or
#     ./net_discovery_reporter.rb -d .


#Require necessary gems or gracefully error/exit if not available
[ 'rubygems','optparse','nmap/xml','caracal' ].each {|required_gem|
  begin
    require required_gem
  rescue LoadError
    puts "The #{required_gem} gem is required to use this script.\n\n"
    puts "In most cases this can be installed with: gem install #{required_gem}"
    exit
  end
}


#Parse command line options
x=nil
options = {}
optparse = OptionParser.new do |opts| 
  #The banner to display at the top
  opts.banner = "\nParse Nmap XML files and output to a Word DOCX table\n\nUsage: net_discover_reporter.rb [options]"
  opts.on( '-f', '--file FILENAME', 'Nmap XML file (singular)' ) { |file| options[:file] = file }
  opts.on( '-d', '--dir PATH', 'Directory of Nmap XML files' ) { |dir| options[:dir] = dir }
  opts.on( '-h', '--help', 'Display this screen' ) { puts opts; exit }
  x=opts
end.parse!(ARGV)


#If no options are specified, output help screen and exit
unless options.any?
  puts x
  exit
end


#Output filename
docx_filename = 'Net_Discovery_Report.docx'


#Instantiate empty arrays
results = []
open_ports = []


#Parse Nmap XML files, adding open ports to an array
def parse_nmap(xml_file, open_ports)
  Nmap::XML.new(xml_file) do |xml|

    xml.each_host do |host|
      ip = host.ip
      host.each_port do |port|
        if port.state == :open
          proto = port.protocol.upcase
          number = port.number
          service = port.service || nil
          if service
            name = service.name
            product = service.product
            version = service.version
          end
          if open_ports.empty?
            open_ports << ["#{ip}","#{host}","#{proto}","#{number}","#{name} #{product} #{version}"]
          else
            found = false
            open_ports.each_with_index do |item, index|
              #If host/port is already in array, and service is longer than existing, replace with longer service
              if (item[0] == ip) && (item[1] == host.to_s) && (item[2] == proto.to_s) && (item[3].to_i == number) && (item[4].to_s.length < "#{name} #{product} #{version}".length)
                puts "Replacing: " + item.to_s + " ... with: " + "['#{ip}', '#{host}', '#{proto}', '#{number}', '#{name} #{product} #{version}']"
                open_ports[index] = ["#{ip}","#{host}","#{proto}","#{number}","#{name} #{product} #{version}"]
                found = true
                break
              #If host/port is already in array, and service is shorter, drop it
              elsif (item[0] == ip) && (item[1] == host.to_s) && (item[2] == proto.to_s) && (item[3].to_i == number) && (item[4].to_s.length > "#{name} #{product} #{version}".length)
                puts "Dropping: " + "['#{ip}', '#{host}', '#{proto}', '#{number}', '#{name} #{product} #{version}']" + " ... longer service string already in array"
                found = true
                break
              #If host/port is already in array, and service is same length, drop it
              elsif (item[0] == ip) && (item[1] == host.to_s) && (item[2] == proto.to_s) && (item[3].to_i == number) && (item[4].to_s.length == "#{name} #{product} #{version}".length)
                found = true
                break
              end
            end
            unless found == true
              open_ports << ["#{ip}","#{host}","#{proto}","#{number}","#{name} #{product} #{version}"]
            end
          end
        end
      end
    end
  end
end


#Create the OOXML tables
def build_tables(open_ports, results)
  ports = []
  count = open_ports.count
  open_ports.sort_by!{ |a,b,c,d,e| a }
  open_ports.each.with_index(1) do |open_port, i|
    ip = open_port[0]
    host = open_port[1]
    proto = open_port[2]
    number = open_port[3]
    service = open_port[4]

    #If first row
    if i == 1
      ports << ["#{proto}","#{number}","#{service}"]
      if ip != open_ports[i][0] 
        #IP column
        ip_col = Caracal::Core::Models::TableCellModel.new do
          p ip
        end
        #Hostname column
        host_col = Caracal::Core::Models::TableCellModel.new do
          p host
        end
        #Ports table
        ports.sort_by!{ |a,b,c| [a,b.to_i] }.reverse
        port_table = Caracal::Core::Models::TableCellModel.new do
          table ports do
            cell_style cols[0],  width: 1200
            cell_style cols[1],  width: 780
            cell_style cols[2],  width: 3420
          end
        end
        #Write to array of caracal tables
        results << [ip_col,host_col,port_table]        
        #Zero ports prior to next host
        ports = []
      end
    elsif i < count
      #If IP is same as next
      if ip == open_ports[i][0] 
        #Save ports to array
        ports << ["#{proto}","#{number}","#{service}"]
      else #If the next row is not the same, write to the results array
        #Save ports to array
        ports << ["#{proto}","#{number}","#{service}"]    
        #IP column
        ip_col = Caracal::Core::Models::TableCellModel.new do
          p ip
        end
        #Hostname column
        host_col = Caracal::Core::Models::TableCellModel.new do
          p host
        end
        #Ports table
        ports.sort_by!{ |a,b,c| [a,b.to_i] }.reverse
        port_table = Caracal::Core::Models::TableCellModel.new do
          table ports do
            cell_style cols[0],  width: 1200
            cell_style cols[1],  width: 780
            cell_style cols[2],  width: 3420
          end
        end
        #Write to array of caracal tables
        results << [ip_col,host_col,port_table]          
        #Zero ports prior to next host
        ports = []
      end
    else #Last row
      ports << ["#{proto}","#{number}","#{service}"]
      #IP column
      ip_col = Caracal::Core::Models::TableCellModel.new do
        p ip
      end
      #Hostname column
      host_col = Caracal::Core::Models::TableCellModel.new do
        p host
      end
      #Ports table
      ports.sort_by!{ |a,b,c| [a,b.to_i] }.reverse
      port_table = Caracal::Core::Models::TableCellModel.new do
        table ports do
          cell_style cols[0],  width: 1200
          cell_style cols[1],  width: 780
          cell_style cols[2],  width: 3420
        end
      end
      #Write to array of caracal tables
      results << [ip_col,host_col,port_table]        
    end
  end
end


#Parse each Nmap XML file
if options[:dir]
  Dir.glob(options[:dir] + '/*.xml').each do |xml_file|
    puts "Parsing: " + xml_file
    parse_nmap(xml_file, open_ports)
  end
else
  puts "Parsing: " + options[:file]
  parse_nmap(options[:file], open_ports)
end


#Create a DOCX file and instantiate it for editing
Caracal::Document.save docx_filename do |docx|
  docx.style do   #Default document style
    id 'Normal'
    name 'Normal'
    font 'Trebuchet MS'
    size '18'   #Measured in half-points (18 = 9pt font)
    line '240'   #Measured in twips
    top '50'   #Measured in twips
  end

  #Create the document header timestamp and options
  docx.p do
    text'Forward delete the space between the two tables and Word will merge them together.', color: 'FF0000', underline: 'true'
    br
    br
    text 'Then, copy to the report selecting "Keep Source Formatting"'
    br
    br
    text 'Generated: ' + DateTime.now.to_s
    br
    br
    text 'options: ' + options.to_s
    br
  end

  #Build the results table
  puts "Building table ..."
  build_tables(open_ports, results)

  #Create the DOCX table from the results array
  header = ['IP Address', 'Hostname (if resolved)', 'Protocol', 'Port', 'Service']
  docx.table [header], border_size: 2 do
    border_color '0085C3'
    cell_style rows[0],  background: '0085C3', color: 'ffffff', bold: true   #Header row blue background, white text
    cell_style cols[0],  width: 1700
    cell_style cols[1],  width: 2360
    cell_style cols[2],  width: 1200
    cell_style cols[3],  width: 780
    cell_style cols[4],  width: 3320
    cell_style cells, margins: { top: 100, bottom: 100, left: 30, right: 0 }
  end

  docx.table results, border_size: 2 do
    border_color '0085C3'
    cell_style cols[0], bold: true, width: 1700
    cell_style cols[1], width: 2360
    cell_style cols[2], width: 5300
    cell_style cells, margins: { top: 0, bottom: 0, left: 30, right: 0 }
  end
  puts "Writing to #{docx_filename}"
end

puts "Done"
