#!/usr/bin/env ruby
#
# net_discovery_reporter.rb
# 
# Net Discovery Reporter will create a Word DOCX formatted table and populate it with parsed results from Nmap/Masscan 
# XML files or Hostwrangled CSV files (ref: @atucom/dotfiles/atu-hostwrangle). 
#
# Output is sorted by target, then protocol, then port number.
#
# If duplicate port listings are found when parsing the input files, the longer service (typically found with sV) will be 
# retained. Any subsequent services for that IP/PORT/PROTO that have the same or shorter service description length will 
# be dropped. This allows you to run the tool with nmap XML output from sT, sS, sU, sV, etc. scans, and it will populate a 
# table of unique open ports with the longest service description retained. 
#
# File format is assumed based on file extension (.xml or .csv). Make your filenames conform or supply a pull request. 
#
# Restrict table output with a line separated file of IPs. Useful when you perform broad "network discovery" scans initially,
# but want to create a slimmed down table (without manual edits) for a final report.
#
# @TheJoSko - 10/03/2016
#
# Installation:
#   gem install ruby-nmap
#   gem install caracal
#
# Usage:
#   Single File:
#     ./net_discovery_reporter.rb -f nmap_oX_file.xml
#   Multiple Files:
#     ./net_discovery_reporter.rb -f nmapsV.xml,nmapsT.xml,sUhostwrangled.csv
#   Directory:
#     ./net_discovery_reporter.rb -d /directory/of/nmap_xml/files/
#     or
#     ./net_discovery_reporter.rb -d .
#   Restrict output to list of IPs:
#     ./net_discovery_reporter.rb -d ./ -t targets.txt


#Require necessary gems or gracefully error/exit if not available
[ 'optparse','csv','nmap/xml','caracal' ].each { |required_gem|
  begin
    require required_gem
  rescue LoadError
    puts "A required dependency is missing. The following gems are required to use this script:"
    puts "  ==>  ruby-nmap"
    puts "  ==>  caracal\n\n"
    puts "In most cases these can be installed with: gem install nmap-ruby caracal"
    exit
  end 
  }


module OpenPorts
  class Host
    attr_accessor :ip, :hostname, :ports
    def initialize(args)
      @ip         = args[:ip]
      @hostname   = args[:hostname]
      self.ports  = {}
    end

    def self.all
      ObjectSpace.each_object(self).to_a
    end

    def add_open_port(args)
      @protocol   = args[:protocol]
      @port       = args[:port]
      @service    = args[:service]

      @port_hash = @port.to_s + "_" + @protocol.to_s
      if is_port_unique(@port_hash, @protocol)
        ports[@port_hash] = {:protocol => @protocol, :service => @service}
      elsif is_service_longer(@port_hash, @service)
        ports[@port_hash] = {:protocol => @protocol, :service => @service}
      end
    end

    def is_port_unique(port_hash, protocol)
      if ports.include? port_hash
        return false 
      end
      true
    end

    def is_service_longer(port_hash, service)
      if ports[port_hash][:service].to_s.strip.length == 0
        return true
      end
      if ports[port_hash][:service].to_s <= service.to_s
        true
      end
    end

    def print_open_ports
      puts "Host: #{@ip}"
      puts "Hostname: #{@hostname}"
      unless ports.empty?
        puts "Ports:"
        ports.each do |port|
          puts "  #{port}"
        end
      end
    end
  end
end



# Print options help if no arguments supplied
ARGV << '-h' if ARGV.empty?


# Options parsing
options = {}
OptionParser.new do |opts|
  opts.banner = "\nUsage: net_discovery_reporter.rb [options]\n"
  opts.on('-f', '--file FILENAME,FILENAME2', Array, 'Nmap XML file (singular, or a comma-separated list)')  { |file| options[:file] = file }
  opts.on('-d', '--dir PATH', 'Directory of Nmap XML files')    { |dir| options[:dir] = dir }
  opts.on('-t', '--targets FILENAME', 'Line separated file of targets to include in table')    { |targets| options[:targets] = targets }
  opts.on_tail('-h', '--help', 'Display this screen')           { puts opts; exit }
end.parse!


# Output filename
DOCX_FILE = 'Net_Discovery_Report.docx'


# Parse a CSV file. Search all objects of Host class to append, or instantiate a new object
def parse_csv(file)
  CSV.foreach(file) do |row|
    if row[4] == "open"
      existing_host = nil
      ObjectSpace.each_object(OpenPorts::Host) do |obj|
        if obj.ip == row[0]
          existing_host = obj
          break
        end
      end
      report_host = existing_host || OpenPorts::Host.new(:ip => row[0], :hostname => row[2])
      service = ''
      service += row[5] + ": " unless row[5].nil?
      service += " " + row[6] unless row[6].nil?
      service += " " + row[7] unless row[7].nil?

      report_host.add_open_port(
        :port       =>  row[1],
        :protocol   =>  row[3].upcase,
        :service    =>  service
        )
    end
  end
end


# Parse a NMAP XML file. Search all objects of Host class to append, or instantiate a new object
def parse_nmap(file)
  Nmap::XML.new(file) do |nmap|
    nmap.each_host do |host|
      host.each_port do |port|
        if port.state == :open
          existing_host = nil
          ObjectSpace.each_object(OpenPorts::Host) do |obj|
            if obj.ip == host.ip
              existing_host = obj
              break
            end
          end
          report_host = existing_host || OpenPorts::Host.new(:ip => host.ip, :hostname => host.to_s)
          service = ''
          service += port.service.name + ": " unless port.service.nil?
          service += " " + port.service.product unless port.service.nil? or port.service.product.nil?
          service += " " + port.service.version unless port.service.nil? or port.service.version.nil?

          report_host.add_open_port(
          :port       =>  port.number,
          :protocol   =>  port.protocol.upcase,
          :service    =>  service
          )
        end
      end
    end
  end
end


#Create the OOXML tables
def build_tables(results, targets)
  # Gather all Hosts objects and sort by :ip, using a schwartzian transform
  host_objs = OpenPorts::Host.all
  host_objs.sort_by! { |host| host.ip.split(".").map(&:to_i) }

  # Interate through each Host object adding class attributes to Caracal array
  host_objs.each do |obj|
    unless targets.empty?
      unless targets.include? obj.ip
        next
      end
    end
    ip_col = Caracal::Core::Models::TableCellModel.new do
      p obj.ip
    end

    host_col = Caracal::Core::Models::TableCellModel.new do
      p obj.hostname
    end

    ports = []
    obj.ports.each do |port|
      ports << [port[0][0..-5], port[1][:protocol], port[1][:service]]
    end
    ports.sort_by! { |port| [port[1].to_s, port[0].to_i] }
    port_table = Caracal::Core::Models::TableCellModel.new do
      table ports do
        cell_style cols[0],  width: 1200
        cell_style cols[1],  width: 780
        cell_style cols[2],  width: 3420
      end
    end
    results << [ip_col,host_col,port_table]
  end
end


targets = []
if options[:targets]
  File.open(options[:targets]).each do |line|
    targets << line
  end
end


#Parse each supplied file
if options[:dir]
  Dir.glob(options[:dir] + "/" + "*.{xml,csv}").each do |file|
    if file.end_with? "xml"
      puts "[+]  Parsing NMAP/Masscan XML file: #{file}"
      parse_nmap(file)
    elsif file.end_with? "csv"
      puts "[+]  Parsing CSV file: #{file}"
      parse_csv(file)
    end
  end
elsif options[:file]
  options[:file].each do |file|
    if file.end_with? "xml"
      puts "[+]  Parsing NMAP/Masscan XML file: #{file}"
      parse_nmap(file)
    elsif file.end_with? "csv"
      puts "[+]  Parsing CSV file: #{file}"
      parse_csv(file)
    else
      puts "[-]  No .xml or .csv files to parse... RTFM"
      exit
    end
  end
end


#Create a DOCX file and instantiate it for editing
Caracal::Document.save DOCX_FILE do |docx|
  docx.style do   #Default document style
    id 'Normal'
    name 'Normal'
    font 'Trebuchet MS'
    size '18'   #Measured in half-points (18 = 9pt font)
    line '240'   #Measured in twips
    top '50'   #Measured in twips
  end

  #Create the document header timestamp and options
  docx.p do
    text'Forward delete the space between the two tables and Word will merge them together.', color: 'FF0000', underline: 'true'
    br
    br
    text 'Then, copy to the report selecting "Keep Source Formatting"'
    br
    br
    text 'Generated: ' + DateTime.now.to_s
    br
    br
    text 'options: ' + options.to_s
    br
  end

  #Build the results table
  puts "[+]  Building table ..."
  puts "[-]  Limiting output to targets specified in #{options[:targets]}" if options[:targets]
  results = []
  build_tables(results, targets)

  #Create the DOCX table from the results array
  header = ['IP Address', 'Hostname (if resolved)', 'Protocol', 'Port', 'Service']
  docx.table [header], border_size: 2 do
    border_color '0085C3'
    cell_style rows[0],  background: '0085C3', color: 'ffffff', bold: true   #Header row blue background, white text
    cell_style cols[0],  width: 1700
    cell_style cols[1],  width: 2360
    cell_style cols[2],  width: 1200
    cell_style cols[3],  width: 780
    cell_style cols[4],  width: 3320
    cell_style cells, margins: { top: 100, bottom: 100, left: 30, right: 0 }
  end

  docx.table results, border_size: 2 do
    border_color '0085C3'
    cell_style cols[0], bold: true, width: 1700
    cell_style cols[1], width: 2360
    cell_style cols[2], width: 5300
    cell_style cells, margins: { top: 0, bottom: 0, left: 30, right: 0 }
  end
  puts "[+]  Writing to #{DOCX_FILE}"
end

puts "[+]  Done"
